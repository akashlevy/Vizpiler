IDRViewer.config = {"pagecount":30,"title":"Modern Compiler Implementation in C","author":"Andrew W. Appel","fileName":"LexingTheory.pdf","bounds":[[935,1210],[935,1210],[935,1210],[935,1210],[935,1210],[935,1210],[935,1210],[935,1210],[935,1210],[935,1210],[935,1210],[935,1210],[818,1066],[818,1066],[818,1066],[818,1066],[818,1066],[818,1066],[818,1066],[818,1066],[818,1066],[818,1066],[818,1066],[818,1066],[818,1066],[818,1066],[818,1066],[818,1066],[818,1066],[818,1066]],"bookmarks":[{"title":"Cover            ","page":-1,"zoom":""},{"title":"Half Title                 ","page":2,"zoom":"XYZ 0 1066 null"},{"title":"Title Page                 ","page":4,"zoom":"XYZ 0 1066 null"},{"title":"Copyright                ","page":5,"zoom":"XYZ 0 1066 null"},{"title":"Content              ","page":6,"zoom":"XYZ 0 1066 null"},{"title":"Preface              ","page":10,"zoom":"XYZ 0 1066 null"},{"title":"Part I Fundamentals of Compilation","page":12,"zoom":"XYZ 0 1066 null","children":[{"title":"1 Introduction                     ","page":14,"zoom":"XYZ 0 1066 null","children":[{"title":"1.1 Modules and interfaces                                 ","page":15,"zoom":"XYZ 0 1066 null"},{"title":"1.2 Tools and software                             ","page":16,"zoom":"XYZ 0 1066 null"},{"title":"1.3 Data structures for tree languages                                             ","page":18,"zoom":"XYZ 0 1066 null"}]},{"title":"2 Lexical Analysis                         ","page":1,"zoom":"XYZ 0 1066 null","children":[{"title":"2.1 Lexical tokens                         ","page":1,"zoom":"XYZ 0 1066 null"},{"title":"2.2 Regular expressions                              ","page":1,"zoom":"XYZ 0 1066 null"},{"title":"2.3 Finite automata                          ","page":1,"zoom":"XYZ 0 1066 null"},{"title":"2.4 Nondeterministic finite automata                                           ","page":1,"zoom":"XYZ 0 1066 null"},{"title":"2.5 Lex: a lexical analyzer generator                                            ","page":1,"zoom":"XYZ 0 1066 null"}]},{"title":"3 Parsing                ","page":1,"zoom":"XYZ 0 1066 null","children":[{"title":"3.1 Context-free grammars                                ","page":1,"zoom":"XYZ 0 1066 null"},{"title":"3.2 Predictive parsing                             ","page":1,"zoom":"XYZ 0 1066 null"},{"title":"3.3 LR parsing                     ","page":1,"zoom":"XYZ 0 1066 null"},{"title":"3.4 Using parser generators                                  ","page":1,"zoom":"XYZ 0 1066 null"},{"title":"3.5 Error recovery                         ","page":1,"zoom":"XYZ 0 1066 null"}]},{"title":"4 Abstract Syntax                        ","page":1,"zoom":"XYZ 0 1066 null","children":[{"title":"4.1 Semantic actions                           ","page":1,"zoom":"XYZ 0 1066 null"},{"title":"4.2 Abstract parse trees","page":1,"zoom":"XYZ 0 1066 null"}]},{"title":"5 Semantic Analysis                          ","page":1,"zoom":"XYZ 0 1066 null","children":[{"title":"5.1 Symbol Tables ","page":1,"zoom":"XYZ 0 1066 null"},{"title":"5.2 Bindings for the Tiger compiler                                          ","page":1,"zoom":"XYZ 0 1066 null"},{"title":"5.3 Type-checking expressions                                    ","page":1,"zoom":"XYZ 0 1066 null"},{"title":"5.4 Type-checking declarations","page":1,"zoom":"XYZ 0 1066 null"}]},{"title":"6 Activation Records                           ","page":1,"zoom":"XYZ 0 1066 null","children":[{"title":"6.1 Stack frames                       ","page":1,"zoom":"XYZ 0 1066 null"},{"title":"6.2 Frames in the Tiger compiler                                       ","page":1,"zoom":"XYZ 0 1066 null"}]},{"title":"7 Translation to Intermediate Code","page":1,"zoom":"XYZ 0 1066 null","children":[{"title":"7.1 Intermediate representation trees                                            ","page":1,"zoom":"XYZ 0 1066 null"},{"title":"7.2 Translation into trees                                 ","page":1,"zoom":"XYZ 0 1066 null"},{"title":"7.3 Declarations                       ","page":1,"zoom":"XYZ 0 1066 null"}]},{"title":"8 Basic Blocks and Traces                                ","page":1,"zoom":"XYZ 0 1066 null","children":[{"title":"8.1 Canonical trees                          ","page":1,"zoom":"XYZ 0 1066 null"},{"title":"8.2 Taming conditional branches                                      ","page":1,"zoom":"XYZ 0 1066 null"}]},{"title":"9 Instruction Selection                              ","page":1,"zoom":"XYZ 0 1066 null","children":[{"title":"9.1 Algorithms for instruction selection                                               ","page":1,"zoom":"XYZ 0 1066 null"},{"title":"9.2 CISC machines                        ","page":1,"zoom":"XYZ 0 1066 null"},{"title":"9.3 Instruction selection for the Tiger compiler                                                       ","page":1,"zoom":"XYZ 0 1066 null"}]},{"title":"10 Liveness Analysis                           ","page":1,"zoom":"XYZ 0 1066 null","children":[{"title":"10.1 Solution of dataflow equations                                          ","page":1,"zoom":"XYZ 0 1066 null"},{"title":"10.2 Liveness in the Tiger compiler                                          ","page":1,"zoom":"XYZ 0 1066 null"}]},{"title":"11 Register Allocation                             ","page":1,"zoom":"XYZ 0 1066 null","children":[{"title":"11.1 Coloring by simplification                                      ","page":1,"zoom":"XYZ 0 1066 null"},{"title":"11.2 Coalescing                      ","page":1,"zoom":"XYZ 0 1066 null"},{"title":"11.3 Precolored nodes                            ","page":1,"zoom":"XYZ 0 1066 null"},{"title":"11.4 Graph coloring implementation                                         ","page":1,"zoom":"XYZ 0 1066 null"},{"title":"11.5 Register allocation for trees                                         ","page":1,"zoom":"XYZ 0 1066 null"}]},{"title":"12 Putting It All Together                                 ","page":1,"zoom":"XYZ 0 1066 null"}]},{"title":"Part II Advanced Topics","page":1,"zoom":"XYZ 0 1066 null","children":[{"title":"13 Garbage Collection                            ","page":1,"zoom":"XYZ 0 1066 null","children":[{"title":"13.1 Mark-and-sweep collection                                     ","page":1,"zoom":"XYZ 0 1066 null"},{"title":"13.2 Reference counts                            ","page":1,"zoom":"XYZ 0 1066 null"},{"title":"13.3 Copying collection                              ","page":1,"zoom":"XYZ 0 1066 null"},{"title":"13.4 Generational collection                                   ","page":1,"zoom":"XYZ 0 1066 null"},{"title":"13.5 Incremental collection                                  ","page":1,"zoom":"XYZ 0 1066 null"},{"title":"13.6 Baker\u2019s algorithm","page":1,"zoom":"XYZ 0 1066 null"},{"title":"13.7 Interface to the compiler                                     ","page":1,"zoom":"XYZ 0 1066 null"}]},{"title":"14 Object-Oriented Languages                                   ","page":1,"zoom":"XYZ 0 1066 null","children":[{"title":"14.1 Classes                   ","page":1,"zoom":"XYZ 0 1066 null"},{"title":"14.2 Single inheritance of data fields                                             ","page":1,"zoom":"XYZ 0 1066 null"},{"title":"14.3 Multiple inheritance                                ","page":1,"zoom":"XYZ 0 1066 null"},{"title":"14.4 Testing class membership                                    ","page":1,"zoom":"XYZ 0 1066 null"},{"title":"14.5 Private fields and methods                                      ","page":1,"zoom":"XYZ 0 1066 null"},{"title":"14.6 Classless languages                               ","page":1,"zoom":"XYZ 0 1066 null"},{"title":"14.7 Optimizing object-oriented programs                                               ","page":1,"zoom":"XYZ 0 1066 null"}]},{"title":"15 Functional Programming Languages                                          ","page":1,"zoom":"XYZ 0 1066 null","children":[{"title":"15.1 A simple functional language                                        ","page":1,"zoom":"XYZ 0 1066 null"},{"title":"15.2 Closures                    ","page":1,"zoom":"XYZ 0 1066 null"},{"title":"15.3 Immutable variables","page":1,"zoom":"XYZ 0 1066 null"},{"title":"15.4 Inline expansion                            ","page":1,"zoom":"XYZ 0 1066 null"},{"title":"15.5 Closure conversion                              ","page":1,"zoom":"XYZ 0 1066 null"},{"title":"15.6 Efficient tail recursion                                    ","page":1,"zoom":"XYZ 0 1066 null"},{"title":"15.7 Lazy evaluation                           ","page":1,"zoom":"XYZ 0 1066 null"}]},{"title":"16 Polymorphic Types                           ","page":1,"zoom":"XYZ 0 1066 null","children":[{"title":"16.1 Parametric polymorphism                                   ","page":1,"zoom":"XYZ 0 1066 null"},{"title":"16.2 Type inference                          ","page":1,"zoom":"XYZ 0 1066 null"},{"title":"16.3 Representation of polymorphic variables                                                   ","page":1,"zoom":"XYZ 0 1066 null"},{"title":"16.4 Resolution of static overloading                                            ","page":1,"zoom":"XYZ 0 1066 null"}]},{"title":"17 Dataflow Analysis                           ","page":1,"zoom":"XYZ 0 1066 null","children":[{"title":"17.1 Intermediate representation for flow analysis                                                         ","page":1,"zoom":"XYZ 0 1066 null"},{"title":"17.2 Various dataflow analyses                                     ","page":1,"zoom":"XYZ 0 1066 null"},{"title":"17.3 Transformations using dataflow analysis                                                   ","page":1,"zoom":"XYZ 0 1066 null"},{"title":"17.4 Speeding up dataflow analysis                                         ","page":1,"zoom":"XYZ 0 1066 null"},{"title":"17.5 Alias analysis","page":1,"zoom":"XYZ 0 1066 null"}]},{"title":"18 Loop Optimizations                            ","page":1,"zoom":"XYZ 0 1066 null","children":[{"title":"18.1 Dominators                      ","page":1,"zoom":"XYZ 0 1066 null"},{"title":"18.2 Loop-invariant computations                                       ","page":1,"zoom":"XYZ 0 1066 null"},{"title":"18.3 Induction variables                               ","page":1,"zoom":"XYZ 0 1066 null"},{"title":"18.4 Array-bounds checks                               ","page":1,"zoom":"XYZ 0 1066 null"},{"title":"18.5 Loop unrolling                          ","page":1,"zoom":"XYZ 0 1066 null"}]},{"title":"19 Static Single-Assignment Form","page":1,"zoom":"XYZ 58 1138 null","children":[{"title":"19.1 Converting to SSA form                                  ","page":1,"zoom":"XYZ 58 1138 null"},{"title":"19.2 Efficient computation of the dominator tree                                                       ","page":1,"zoom":"XYZ 58 1138 null"},{"title":"19.3 Optimization algorithms using SSA                                             ","page":1,"zoom":"XYZ 58 1138 null"},{"title":"19.4 Arrays, pointers, and memory                                        ","page":1,"zoom":"XYZ 58 1138 null"},{"title":"19.5 The control-dependence graph                                        ","page":1,"zoom":"XYZ 58 1138 null"},{"title":"19.6 Converting back from SSA form                                         ","page":1,"zoom":"XYZ 0 1066 null"},{"title":"19.7 A functional intermediate form                                          ","page":1,"zoom":"XYZ 0 1066 null"}]},{"title":"20 Pipelining and Scheduling","page":1,"zoom":"XYZ 0 1066 null","children":[{"title":"20.1 Loop scheduling without resource bounds                                                   ","page":1,"zoom":"XYZ 0 1066 null"},{"title":"20.2 Resource-bounded loop pipelining                                            ","page":1,"zoom":"XYZ 0 1066 null"},{"title":"20.3 Branch prediction                             ","page":1,"zoom":"XYZ 0 1066 null"}]},{"title":"21 The Memory Hierarchy                              ","page":1,"zoom":"XYZ 0 1066 null","children":[{"title":"21.1 Cache organization                              ","page":1,"zoom":"XYZ 0 1066 null"},{"title":"21.2 Cache-block alignment                                 ","page":1,"zoom":"XYZ 0 1066 null"},{"title":"21.3 Prefetching                       ","page":1,"zoom":"XYZ 0 1066 null"},{"title":"21.4 Loop interchange                            ","page":1,"zoom":"XYZ 0 1066 null"},{"title":"21.5 Blocking                    ","page":1,"zoom":"XYZ 0 1066 null"},{"title":"21.6 Garbage collection and the memory hierarchy                                                       ","page":1,"zoom":"XYZ 0 1066 null"}]}]},{"title":"Appendix: Tiger Language Reference Manual                                                ","page":1,"zoom":"XYZ 0 1066 null","children":[{"title":"A.1 Lexical issues                         ","page":1,"zoom":"XYZ 0 1066 null"},{"title":"A.2 Declarations                       ","page":1,"zoom":"XYZ 0 1066 null"},{"title":"A.3 Variables and expressions                                    ","page":1,"zoom":"XYZ 0 1066 null"},{"title":"A.4 Standard library                           ","page":1,"zoom":"XYZ 0 1066 null"},{"title":"A.5 Sample Tiger programs                                ","page":1,"zoom":"XYZ 0 1066 null"}]},{"title":"Bibliography                   ","page":1,"zoom":"XYZ 0 1066 null"},{"title":"Index            ","page":1,"zoom":"XYZ 0 1066 null"}],"thumbnailType":"jpg","pageType":"html","pageLabels":[]};