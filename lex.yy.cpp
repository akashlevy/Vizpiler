// lex.yy.cpp generated by reflex 0.9.22 from 

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  OPTIONS USED                                                              //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#define REFLEX_OPTION_graphs_file         stdout
#define REFLEX_OPTION_lex                 lex
#define REFLEX_OPTION_lexer               Lexer
#define REFLEX_OPTION_outfile             lex.yy.cpp

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  REGEX MATCHER                                                             //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/matcher.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  ABSTRACT LEXER CLASS                                                      //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/abslexer.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  LEXER CLASS                                                               //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

class Lexer : public reflex::AbstractLexer<reflex::Matcher> {
 public:
  typedef reflex::AbstractLexer<reflex::Matcher> AbstractBaseLexer;
  Lexer(
      const reflex::Input& input = reflex::Input(),
      std::ostream&        os    = std::cout)
    :
      AbstractBaseLexer(input, os)
  {
  }
  static const int INITIAL = 0;
  virtual int lex();
  int lex(
      const reflex::Input& input,
      std::ostream        *os = NULL)
  {
    in(input);
    if (os)
      out(*os);
    return lex();
  }
};

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %{ user code %}                                                //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 1

#include <stdlib.h>
#include "calc3.h"
#include "y.tab.h"
void yyerror(char *);


////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 2: rules                                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

int Lexer::lex()
{
  static const reflex::Pattern PATTERN_INITIAL("(?m)([a-z])|(0)|([1-9][0-9]*)|([(-+\\x2d-/;->\\x7b\\x7d])|((?:\\Q>=\\E))|((?:\\Q<=\\E))|((?:\\Q==\\E))|((?:\\Q!=\\E))|((?:\\Qwhile\\E))|((?:\\Qif\\E))|((?:\\Qelse\\E))|((?:\\Qprint\\E))|([\\x09\\x0a\\x20]+)|(.)");
  if (!has_matcher())
  {
    matcher(new Matcher(PATTERN_INITIAL, stdinit(), this));
  }
  while (true)
  {
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              return 0;
            }
            else
            {
              out().put(matcher().input());
            }
            break;
          case 1: // rule at line 10: [a-z]
#line 10
{
                yylval.sIndex = *yytext - 'a';
                return VARIABLE;
            }

            break;
          case 2: // rule at line 15: 0
#line 15
{
                yylval.iValue = atoi(yytext);
                return INTEGER;
            }

            break;
          case 3: // rule at line 20: [1-9][0-9]*
#line 20
{
                yylval.iValue = atoi(yytext);
                return INTEGER;
            }

            break;
          case 4: // rule at line 25: [(-+\x2d-/;->\x7b\x7d]
#line 25
{
                return *yytext;
             }

            break;
          case 5: // rule at line 29: (?:\Q>=\E)
#line 29
return GE;
            break;
          case 6: // rule at line 30: (?:\Q<=\E)
#line 30
return LE;
            break;
          case 7: // rule at line 31: (?:\Q==\E)
#line 31
return EQ;
            break;
          case 8: // rule at line 32: (?:\Q!=\E)
#line 32
return NE;
            break;
          case 9: // rule at line 33: (?:\Qwhile\E)
#line 33
return WHILE;
            break;
          case 10: // rule at line 34: (?:\Qif\E)
#line 34
return IF;
            break;
          case 11: // rule at line 35: (?:\Qelse\E)
#line 35
return ELSE;
            break;
          case 12: // rule at line 36: (?:\Qprint\E)
#line 36
return PRINT;

            break;
          case 13: // rule at line 38: [\x09\x0a\x20]+
#line 38
;       /* ignore whitespace */

            break;
          case 14: // rule at line 40: .
#line 40
yyerror("Unknown character");

            break;
        }
  }
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 3: user code                                                      //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 43

int yywrap(void) {
    return 1;
}
